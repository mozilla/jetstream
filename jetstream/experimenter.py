import datetime as dt
from typing import List, Iterable, Optional, Union, Any, Callable

import attr
import cattr
import logging
import requests
import pytz

logger = logging.getLogger(__name__)


@attr.s(auto_attribs=True, kw_only=True, slots=True, frozen=True)
class Variant:
    is_control: bool
    slug: str
    ratio: int


def _coerce_none_to_zero(x: Optional[int]) -> int:
    return 0 if x is None else x


@attr.s(auto_attribs=True, kw_only=True, slots=True, frozen=True)
class Branch:
    slug: str
    ratio: int


@attr.s(auto_attribs=True, kw_only=True, slots=True, frozen=True)
class Experiment:
    """
    Common Experimenter experiment representation.
    Attributes:
        experimenter_slug: Slug generated by Experimenter for V1 experiments;
            None for V4 experiments
        normandy_slug: V1 experiment normandy_slug; V4 experiment slug
        type: V1 experiment type; always "v4" for V4 experiments
        status: V1 experiment status; "Live" for active V4 experiments,
            "Complete" for inactive V4 experiments
        features: empty list for V1 experiments; slugs for V4 experiment features
        branches: V1 experiment variants converted to branches; V4 experiment branches
        start_date: experiment start_date
        end_date: experiment end_date
        proposed_enrollment: experiment proposed_enrollment
        reference_branch: V1 experiment branch slug where is_control is True;
            V4 experiment reference_branch
    """

    experimenter_slug: Optional[str]
    normandy_slug: Optional[str]
    type: str
    status: Optional[str]
    features: List[str]
    branches: List[Branch]
    start_date: Optional[dt.datetime]
    end_date: Optional[dt.datetime]
    proposed_enrollment: Optional[int]
    reference_branch: Optional[str]
    is_high_population: bool


@attr.s(auto_attribs=True, kw_only=True, slots=True, frozen=True)
class ExperimentV1:
    """Experimenter v1 experiment."""

    slug: str  # experimenter slug
    type: str
    status: str
    start_date: Optional[dt.datetime]
    end_date: Optional[dt.datetime]
    proposed_enrollment: Optional[int] = attr.ib(converter=_coerce_none_to_zero)
    variants: List[Variant]
    normandy_slug: Optional[str] = None
    is_high_population: Optional[bool] = None

    @staticmethod
    def _unix_millis_to_datetime(num: Optional[float]) -> Optional[dt.datetime]:
        if num is None:
            return None
        return dt.datetime.fromtimestamp(num / 1e3, pytz.utc)

    @classmethod
    def from_dict(cls, d) -> "ExperimentV1":
        converter = cattr.Converter()
        converter.register_structure_hook(
            dt.datetime,
            lambda num, _: cls._unix_millis_to_datetime(num),
        )
        return converter.structure(d, cls)

    def to_experiment(self) -> "Experiment":
        """Convert to Experiment."""
        branches = [Branch(slug=variant.slug, ratio=variant.ratio) for variant in self.variants]
        control_slug = None

        control_slugs = [variant.slug for variant in self.variants if variant.is_control]
        if len(control_slugs) == 1:
            control_slug = control_slugs[0]

        return Experiment(
            normandy_slug=self.normandy_slug,
            experimenter_slug=self.slug,
            type=self.type,
            status=self.status,
            start_date=self.start_date,
            end_date=self.end_date,
            proposed_enrollment=self.proposed_enrollment,
            features=[],
            branches=branches,
            reference_branch=control_slug,
            is_high_population=self.is_high_population or False,
        )


@attr.s(auto_attribs=True, kw_only=True, slots=True, frozen=True)
class ExperimentV4:
    """Represents a v4 experiment from Experimenter."""

    slug: str  # Normandy slug
    active: bool
    features: List[str]
    branches: List[Branch]
    startDate: dt.datetime
    endDate: Optional[dt.datetime]
    proposedEnrollment: int
    referenceBranch: Optional[str]

    @classmethod
    def from_dict(cls, d) -> "ExperimentV4":
        converter = cattr.Converter()
        converter.register_structure_hook(
            dt.datetime,
            lambda num, _: pytz.utc.localize(dt.datetime.strptime(num, "%Y-%m-%d")),
        )
        return converter.structure(d, cls)

    def to_experiment(self) -> "Experiment":
        """Convert to Experiment."""
        return Experiment(
            normandy_slug=self.slug,
            experimenter_slug=None,
            type="v4",
            status="Live" if self.active else "Complete",
            start_date=self.startDate,
            end_date=self.endDate,
            proposed_enrollment=self.proposedEnrollment,
            features=self.features,
            branches=self.branches,
            reference_branch=self.referenceBranch,
            is_high_population=False,
        )


@attr.s(auto_attribs=True)
class ExperimentCollection:
    experiments: List[Experiment] = attr.Factory(list)

    EXPERIMENTER_API_URL_V1 = "https://experimenter.services.mozilla.com/api/v1/experiments/"

    # for nimbus experiments
    EXPERIMENTER_API_URL_V4 = "https://experimenter.services.mozilla.com/api/v4/experiments/"

    @classmethod
    def _handle_errors(cls, func: Callable[[], Any], slug: str) -> Optional[Experiment]:
        """Handles exceptions when pulling in and working with experiments from Experimenter."""
        try:
            return func()
        except Exception as e:
            logger.exception(str(e), exc_info=e, extra={"experiment": slug})
            return None

    @classmethod
    def from_experimenter(cls, session: requests.Session = None) -> "ExperimentCollection":
        session = session or requests.Session()
        legacy_experiments_json = session.get(cls.EXPERIMENTER_API_URL_V1).json()

        legacy_experiments = [
            e
            for experiment in legacy_experiments_json
            if experiment["type"] != "rapid"
            and (
                e := cls._handle_errors(
                    lambda: ExperimentV1.from_dict(experiment).to_experiment(),
                    experiment["slug"],
                )
            )
            is not None
        ]

        nimbus_experiments_json = session.get(cls.EXPERIMENTER_API_URL_V4).json()
        nimbus_experiments = [
            ex
            for experiment in nimbus_experiments_json
            if (
                ex := cls._handle_errors(
                    lambda: ExperimentV4.from_dict(experiment["arguments"]).to_experiment(),
                    experiment["arguments"]["slug"],
                )
            )
            is not None
        ]

        return cls(nimbus_experiments + legacy_experiments)

    def of_type(self, type_or_types: Union[str, Iterable[str]]) -> "ExperimentCollection":
        if isinstance(type_or_types, str):
            type_or_types = (type_or_types,)
        cls = type(self)
        return cls([ex for ex in self.experiments if ex.type in type_or_types])

    def ever_launched(self) -> "ExperimentCollection":
        cls = type(self)
        return cls(
            [
                ex
                for ex in self.experiments
                if ex.status in ("Complete", "Live") or ex.status is None
            ]
        )

    def with_slug(self, slug: str) -> "ExperimentCollection":
        cls = type(self)
        return cls(
            [
                ex
                for ex in self.experiments
                if ex.experimenter_slug == slug or ex.normandy_slug == slug
            ]
        )

    def started_since(self, since: dt.datetime) -> "ExperimentCollection":
        """All experiments that ever launched after a given time.

        since should be a tz-aware datetime."""
        cls = type(self)
        return cls(
            [
                ex
                for ex in self.ever_launched().experiments
                if ex.start_date and ex.start_date >= since
            ]
        )

    def end_on_or_after(self, after: dt.datetime) -> "ExperimentCollection":
        """All experiments that ever launched that end on or after the specified time.

        after should be a tz-aware datetime."""
        cls = type(self)
        return cls(
            [ex for ex in self.ever_launched().experiments if ex.end_date and ex.end_date >= after]
        )
